#' Bootstrap Confidence intervals for dbICC
#' 
#' Nonparametric bootstrapping can be used to construct confidence 
#' intervals for the Distance-based Intraclass Correlation Coefficient 
#' (dbICC) based on samples of the subjects with replacement.
#' 
#' @param dmat A distance matrix or a object of \code{dist}, of dimension \code{sum(nmea)*sum(nmea)}. Note that the order of the rows or
#' columns in the distance matrix is grouped by subjects or individuals. The details refer to Figure 1 of
#' Reiss el at., 2019.
#' @param nsub Number of subject or individual.
#' @param nmea A vector containing number of the measurement for each subject or individual; 
#' if \code{nmea} is a scalar, it means each subject shares the same number of the measurement.
#' @param bootsamp A sample with replacement.
#' 
#' @param adhoc A logical variable, whether to apply the ad hoc correction when
#' estimating the dbICC from a bootstrap sample. Default is \code{FALSE}.
#' @return A scalar, giving the dbICC value
#' 
#' @author Meng Xu \email{mxu@@campus.haifa.ac.il}, Philip Reiss
#' 
#' @seealso \code{\link{plotdmat}},\code{\link{dm2icc}}
#' 
#' @references
#' \itemize{
#' \item Reiss et al. (2019). Generalized test-retest reliability based on distances. 
#' }
#' 
#' @keywords Bootstrap, dbICC, reliability
#' @import Matrix MASS
#' @export
#' @examples
#' 
#' ##Point estimates of dbICC
#' 
#' # Generation function for R^2 points from multi-normal distribution
#' R2gen<-function(nsub,nmea,m=1,variance,sds=NULL,pt=FALSE){
#'     if (is.null(sds)==FALSE) set.seed(sds)
#'     if (length(nmea)==1) nmea<-rep(1,nsub)*nmea
#'     sig1<-diag(rep(variance,2))
#'     mu<-c(0,0)
#'     sig2<-diag(rep(1,2))
#'     t<-MASS::mvrnorm(nsub,mu,sig2)
#'     e<-MASS::mvrnorm(sum(nmea),mu,sig1/m)
#'     p<-matrix(apply(t,2,rep,times=nmea),ncol=2)+e#(I*J)x2
#'     if (pt==TRUE) return(list(t=t,p=p))
#'     if (pt==FALSE) return(p)
#' }
#' 
#' # set the number of the point
#' I <- 10
#' 
#' # set the number of the measurement for each point
#' J <- 4
#' 
#' # generate the sample of R^2 points
#' varl <- .25 # variance of the 2-d normal distribution
#' pij <- R2gen(I,J,variance=varl)
#' 
#' # calculate the squared distance matrix via Euclidean distance
#' distmat<-as.matrix(dist(pij))
#' 
#' ##Bootstrap Confident intervals
#' 
#' B <- 500
#' bicc <- numeric(B)
#' for (b in 1:B){
#'     bs <- sort(sample(I, replace = TRUE))
#'     bicc[b] <- boot.dbicc(distmat,I,J,bootsamp=bs)
#' }
#' 
#' quantile(bicc, c(.025, .975))
#' 
 
boot.dbicc <-
function(dmat, nsub, nmea, bootsamp, adhoc = FALSE) {
  #nmea: the number of the measurement
  if (length(nmea)==1) nmea<-rep(nmea,nsub)
  dmat<-as.matrix(dmat^2)
  wmask <- as.matrix(Matrix::bdiag(lapply(nmea, function(i) matrix(1, i, i))))
  diag(wmask) <- NA
  bmask <- matrix(1, sum(nmea), sum(nmea)) - wmask
  wmask[wmask == 0] <- bmask[bmask == 0] <- NA
  bmask.ah <- bmask
  if (!all(1:nsub %in% bootsamp)){
    wibs <- sapply(bootsamp, function(i) sum(nmea[1:i - 1]) + 1:nmea[i])
    dboot <- dmat[wibs, wibs]
    if (adhoc) {
      for (ii in 1:(nsub - 1))
        for (jj in (ii + 1):nsub) {
          if (bootsamp[ii] == bootsamp[jj]) bmask.ah[(sum(nmea[1:ii - 1]) + 1:nmea[ii]), (sum(nmea[1:jj - 1]) + 1:nmea[jj])] <- bmask.ah[(sum(nmea[1:jj - 1]) + 1:nmea[jj]), (sum(nmea[1:ii - 1]) + 1:nmea[ii])] <- NA
        }
    }
  }
  else dboot<-dmat
  1 - mean(dboot * wmask, na.rm = TRUE) / mean(dboot * bmask.ah, na.rm = TRUE)
}
